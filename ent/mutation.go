// Code generated by entc, DO NOT EDIT.

package ent

import (
	"app/ent/characterfields"
	"app/ent/person"
	"app/ent/personcsindex"
	"app/ent/predicate"
	"context"
	"fmt"
	"sync"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCharacterFields = "CharacterFields"
	TypePerson          = "Person"
	TypePersonCsIndex   = "PersonCsIndex"
)

// CharacterFieldsMutation represents an operation that mutates the CharacterFields nodes in the graph.
type CharacterFieldsMutation struct {
	config
	op            Op
	typ           string
	id            *uint8
	prsn_cat      *characterfields.PrsnCat
	gender        *int
	addgender     *int
	bloodtype     *int
	addbloodtype  *int
	birth_year    *int
	addbirth_year *int
	birth_mon     *int
	addbirth_mon  *int
	birth_day     *int
	addbirth_day  *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CharacterFields, error)
	predicates    []predicate.CharacterFields
}

var _ ent.Mutation = (*CharacterFieldsMutation)(nil)

// characterfieldsOption allows management of the mutation configuration using functional options.
type characterfieldsOption func(*CharacterFieldsMutation)

// newCharacterFieldsMutation creates new mutation for the CharacterFields entity.
func newCharacterFieldsMutation(c config, op Op, opts ...characterfieldsOption) *CharacterFieldsMutation {
	m := &CharacterFieldsMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacterFields,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterFieldsID sets the ID field of the mutation.
func withCharacterFieldsID(id uint8) characterfieldsOption {
	return func(m *CharacterFieldsMutation) {
		var (
			err   error
			once  sync.Once
			value *CharacterFields
		)
		m.oldValue = func(ctx context.Context) (*CharacterFields, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CharacterFields.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacterFields sets the old CharacterFields of the mutation.
func withCharacterFields(node *CharacterFields) characterfieldsOption {
	return func(m *CharacterFieldsMutation) {
		m.oldValue = func(context.Context) (*CharacterFields, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterFieldsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterFieldsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CharacterFields entities.
func (m *CharacterFieldsMutation) SetID(id uint8) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterFieldsMutation) ID() (id uint8, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrsnCat sets the "prsn_cat" field.
func (m *CharacterFieldsMutation) SetPrsnCat(cc characterfields.PrsnCat) {
	m.prsn_cat = &cc
}

// PrsnCat returns the value of the "prsn_cat" field in the mutation.
func (m *CharacterFieldsMutation) PrsnCat() (r characterfields.PrsnCat, exists bool) {
	v := m.prsn_cat
	if v == nil {
		return
	}
	return *v, true
}

// OldPrsnCat returns the old "prsn_cat" field's value of the CharacterFields entity.
// If the CharacterFields object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterFieldsMutation) OldPrsnCat(ctx context.Context) (v characterfields.PrsnCat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrsnCat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrsnCat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrsnCat: %w", err)
	}
	return oldValue.PrsnCat, nil
}

// ResetPrsnCat resets all changes to the "prsn_cat" field.
func (m *CharacterFieldsMutation) ResetPrsnCat() {
	m.prsn_cat = nil
}

// SetGender sets the "gender" field.
func (m *CharacterFieldsMutation) SetGender(i int) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *CharacterFieldsMutation) Gender() (r int, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the CharacterFields entity.
// If the CharacterFields object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterFieldsMutation) OldGender(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *CharacterFieldsMutation) AddGender(i int) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *CharacterFieldsMutation) AddedGender() (r int, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *CharacterFieldsMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetBloodtype sets the "bloodtype" field.
func (m *CharacterFieldsMutation) SetBloodtype(i int) {
	m.bloodtype = &i
	m.addbloodtype = nil
}

// Bloodtype returns the value of the "bloodtype" field in the mutation.
func (m *CharacterFieldsMutation) Bloodtype() (r int, exists bool) {
	v := m.bloodtype
	if v == nil {
		return
	}
	return *v, true
}

// OldBloodtype returns the old "bloodtype" field's value of the CharacterFields entity.
// If the CharacterFields object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterFieldsMutation) OldBloodtype(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBloodtype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBloodtype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBloodtype: %w", err)
	}
	return oldValue.Bloodtype, nil
}

// AddBloodtype adds i to the "bloodtype" field.
func (m *CharacterFieldsMutation) AddBloodtype(i int) {
	if m.addbloodtype != nil {
		*m.addbloodtype += i
	} else {
		m.addbloodtype = &i
	}
}

// AddedBloodtype returns the value that was added to the "bloodtype" field in this mutation.
func (m *CharacterFieldsMutation) AddedBloodtype() (r int, exists bool) {
	v := m.addbloodtype
	if v == nil {
		return
	}
	return *v, true
}

// ResetBloodtype resets all changes to the "bloodtype" field.
func (m *CharacterFieldsMutation) ResetBloodtype() {
	m.bloodtype = nil
	m.addbloodtype = nil
}

// SetBirthYear sets the "birth_year" field.
func (m *CharacterFieldsMutation) SetBirthYear(i int) {
	m.birth_year = &i
	m.addbirth_year = nil
}

// BirthYear returns the value of the "birth_year" field in the mutation.
func (m *CharacterFieldsMutation) BirthYear() (r int, exists bool) {
	v := m.birth_year
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthYear returns the old "birth_year" field's value of the CharacterFields entity.
// If the CharacterFields object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterFieldsMutation) OldBirthYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthYear: %w", err)
	}
	return oldValue.BirthYear, nil
}

// AddBirthYear adds i to the "birth_year" field.
func (m *CharacterFieldsMutation) AddBirthYear(i int) {
	if m.addbirth_year != nil {
		*m.addbirth_year += i
	} else {
		m.addbirth_year = &i
	}
}

// AddedBirthYear returns the value that was added to the "birth_year" field in this mutation.
func (m *CharacterFieldsMutation) AddedBirthYear() (r int, exists bool) {
	v := m.addbirth_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthYear resets all changes to the "birth_year" field.
func (m *CharacterFieldsMutation) ResetBirthYear() {
	m.birth_year = nil
	m.addbirth_year = nil
}

// SetBirthMon sets the "birth_mon" field.
func (m *CharacterFieldsMutation) SetBirthMon(i int) {
	m.birth_mon = &i
	m.addbirth_mon = nil
}

// BirthMon returns the value of the "birth_mon" field in the mutation.
func (m *CharacterFieldsMutation) BirthMon() (r int, exists bool) {
	v := m.birth_mon
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthMon returns the old "birth_mon" field's value of the CharacterFields entity.
// If the CharacterFields object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterFieldsMutation) OldBirthMon(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthMon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthMon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthMon: %w", err)
	}
	return oldValue.BirthMon, nil
}

// AddBirthMon adds i to the "birth_mon" field.
func (m *CharacterFieldsMutation) AddBirthMon(i int) {
	if m.addbirth_mon != nil {
		*m.addbirth_mon += i
	} else {
		m.addbirth_mon = &i
	}
}

// AddedBirthMon returns the value that was added to the "birth_mon" field in this mutation.
func (m *CharacterFieldsMutation) AddedBirthMon() (r int, exists bool) {
	v := m.addbirth_mon
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthMon resets all changes to the "birth_mon" field.
func (m *CharacterFieldsMutation) ResetBirthMon() {
	m.birth_mon = nil
	m.addbirth_mon = nil
}

// SetBirthDay sets the "birth_day" field.
func (m *CharacterFieldsMutation) SetBirthDay(i int) {
	m.birth_day = &i
	m.addbirth_day = nil
}

// BirthDay returns the value of the "birth_day" field in the mutation.
func (m *CharacterFieldsMutation) BirthDay() (r int, exists bool) {
	v := m.birth_day
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDay returns the old "birth_day" field's value of the CharacterFields entity.
// If the CharacterFields object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterFieldsMutation) OldBirthDay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDay: %w", err)
	}
	return oldValue.BirthDay, nil
}

// AddBirthDay adds i to the "birth_day" field.
func (m *CharacterFieldsMutation) AddBirthDay(i int) {
	if m.addbirth_day != nil {
		*m.addbirth_day += i
	} else {
		m.addbirth_day = &i
	}
}

// AddedBirthDay returns the value that was added to the "birth_day" field in this mutation.
func (m *CharacterFieldsMutation) AddedBirthDay() (r int, exists bool) {
	v := m.addbirth_day
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthDay resets all changes to the "birth_day" field.
func (m *CharacterFieldsMutation) ResetBirthDay() {
	m.birth_day = nil
	m.addbirth_day = nil
}

// Where appends a list predicates to the CharacterFieldsMutation builder.
func (m *CharacterFieldsMutation) Where(ps ...predicate.CharacterFields) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CharacterFieldsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CharacterFields).
func (m *CharacterFieldsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterFieldsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.prsn_cat != nil {
		fields = append(fields, characterfields.FieldPrsnCat)
	}
	if m.gender != nil {
		fields = append(fields, characterfields.FieldGender)
	}
	if m.bloodtype != nil {
		fields = append(fields, characterfields.FieldBloodtype)
	}
	if m.birth_year != nil {
		fields = append(fields, characterfields.FieldBirthYear)
	}
	if m.birth_mon != nil {
		fields = append(fields, characterfields.FieldBirthMon)
	}
	if m.birth_day != nil {
		fields = append(fields, characterfields.FieldBirthDay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterFieldsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case characterfields.FieldPrsnCat:
		return m.PrsnCat()
	case characterfields.FieldGender:
		return m.Gender()
	case characterfields.FieldBloodtype:
		return m.Bloodtype()
	case characterfields.FieldBirthYear:
		return m.BirthYear()
	case characterfields.FieldBirthMon:
		return m.BirthMon()
	case characterfields.FieldBirthDay:
		return m.BirthDay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterFieldsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case characterfields.FieldPrsnCat:
		return m.OldPrsnCat(ctx)
	case characterfields.FieldGender:
		return m.OldGender(ctx)
	case characterfields.FieldBloodtype:
		return m.OldBloodtype(ctx)
	case characterfields.FieldBirthYear:
		return m.OldBirthYear(ctx)
	case characterfields.FieldBirthMon:
		return m.OldBirthMon(ctx)
	case characterfields.FieldBirthDay:
		return m.OldBirthDay(ctx)
	}
	return nil, fmt.Errorf("unknown CharacterFields field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterFieldsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case characterfields.FieldPrsnCat:
		v, ok := value.(characterfields.PrsnCat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrsnCat(v)
		return nil
	case characterfields.FieldGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case characterfields.FieldBloodtype:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBloodtype(v)
		return nil
	case characterfields.FieldBirthYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthYear(v)
		return nil
	case characterfields.FieldBirthMon:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthMon(v)
		return nil
	case characterfields.FieldBirthDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDay(v)
		return nil
	}
	return fmt.Errorf("unknown CharacterFields field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterFieldsMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, characterfields.FieldGender)
	}
	if m.addbloodtype != nil {
		fields = append(fields, characterfields.FieldBloodtype)
	}
	if m.addbirth_year != nil {
		fields = append(fields, characterfields.FieldBirthYear)
	}
	if m.addbirth_mon != nil {
		fields = append(fields, characterfields.FieldBirthMon)
	}
	if m.addbirth_day != nil {
		fields = append(fields, characterfields.FieldBirthDay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterFieldsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case characterfields.FieldGender:
		return m.AddedGender()
	case characterfields.FieldBloodtype:
		return m.AddedBloodtype()
	case characterfields.FieldBirthYear:
		return m.AddedBirthYear()
	case characterfields.FieldBirthMon:
		return m.AddedBirthMon()
	case characterfields.FieldBirthDay:
		return m.AddedBirthDay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterFieldsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case characterfields.FieldGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case characterfields.FieldBloodtype:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBloodtype(v)
		return nil
	case characterfields.FieldBirthYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthYear(v)
		return nil
	case characterfields.FieldBirthMon:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthMon(v)
		return nil
	case characterfields.FieldBirthDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthDay(v)
		return nil
	}
	return fmt.Errorf("unknown CharacterFields numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterFieldsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterFieldsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterFieldsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CharacterFields nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterFieldsMutation) ResetField(name string) error {
	switch name {
	case characterfields.FieldPrsnCat:
		m.ResetPrsnCat()
		return nil
	case characterfields.FieldGender:
		m.ResetGender()
		return nil
	case characterfields.FieldBloodtype:
		m.ResetBloodtype()
		return nil
	case characterfields.FieldBirthYear:
		m.ResetBirthYear()
		return nil
	case characterfields.FieldBirthMon:
		m.ResetBirthMon()
		return nil
	case characterfields.FieldBirthDay:
		m.ResetBirthDay()
		return nil
	}
	return fmt.Errorf("unknown CharacterFields field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterFieldsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterFieldsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterFieldsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterFieldsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterFieldsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterFieldsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterFieldsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CharacterFields unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterFieldsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CharacterFields edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	_type          *string
	infobox        *string
	producer       *int
	addproducer    *int
	mangaka        *int
	addmangaka     *int
	artist         *int
	addartist      *int
	seiyu          *int
	addseiyu       *int
	writer         *int
	addwriter      *int
	illustrator    *int
	addillustrator *int
	actor          *int
	addactor       *int
	summary        *string
	img            *string
	img_anidb      *string
	comment        *int
	addcomment     *int
	collects       *int
	addcollects    *int
	dateline       *int
	adddateline    *int
	lastpost       *int
	addlastpost    *int
	lock           *int
	addlock        *int
	anidb_id       *string
	ban            *int
	addban         *int
	redirect       *int
	addredirect    *int
	nsfw           *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Person, error)
	predicates     []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id int) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Person entities.
func (m *PersonMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *PersonMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PersonMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PersonMutation) ResetType() {
	m._type = nil
}

// SetInfobox sets the "infobox" field.
func (m *PersonMutation) SetInfobox(s string) {
	m.infobox = &s
}

// Infobox returns the value of the "infobox" field in the mutation.
func (m *PersonMutation) Infobox() (r string, exists bool) {
	v := m.infobox
	if v == nil {
		return
	}
	return *v, true
}

// OldInfobox returns the old "infobox" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldInfobox(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfobox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfobox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfobox: %w", err)
	}
	return oldValue.Infobox, nil
}

// ResetInfobox resets all changes to the "infobox" field.
func (m *PersonMutation) ResetInfobox() {
	m.infobox = nil
}

// SetProducer sets the "producer" field.
func (m *PersonMutation) SetProducer(i int) {
	m.producer = &i
	m.addproducer = nil
}

// Producer returns the value of the "producer" field in the mutation.
func (m *PersonMutation) Producer() (r int, exists bool) {
	v := m.producer
	if v == nil {
		return
	}
	return *v, true
}

// OldProducer returns the old "producer" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldProducer(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProducer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProducer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProducer: %w", err)
	}
	return oldValue.Producer, nil
}

// AddProducer adds i to the "producer" field.
func (m *PersonMutation) AddProducer(i int) {
	if m.addproducer != nil {
		*m.addproducer += i
	} else {
		m.addproducer = &i
	}
}

// AddedProducer returns the value that was added to the "producer" field in this mutation.
func (m *PersonMutation) AddedProducer() (r int, exists bool) {
	v := m.addproducer
	if v == nil {
		return
	}
	return *v, true
}

// ResetProducer resets all changes to the "producer" field.
func (m *PersonMutation) ResetProducer() {
	m.producer = nil
	m.addproducer = nil
}

// SetMangaka sets the "mangaka" field.
func (m *PersonMutation) SetMangaka(i int) {
	m.mangaka = &i
	m.addmangaka = nil
}

// Mangaka returns the value of the "mangaka" field in the mutation.
func (m *PersonMutation) Mangaka() (r int, exists bool) {
	v := m.mangaka
	if v == nil {
		return
	}
	return *v, true
}

// OldMangaka returns the old "mangaka" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMangaka(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMangaka is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMangaka requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMangaka: %w", err)
	}
	return oldValue.Mangaka, nil
}

// AddMangaka adds i to the "mangaka" field.
func (m *PersonMutation) AddMangaka(i int) {
	if m.addmangaka != nil {
		*m.addmangaka += i
	} else {
		m.addmangaka = &i
	}
}

// AddedMangaka returns the value that was added to the "mangaka" field in this mutation.
func (m *PersonMutation) AddedMangaka() (r int, exists bool) {
	v := m.addmangaka
	if v == nil {
		return
	}
	return *v, true
}

// ResetMangaka resets all changes to the "mangaka" field.
func (m *PersonMutation) ResetMangaka() {
	m.mangaka = nil
	m.addmangaka = nil
}

// SetArtist sets the "artist" field.
func (m *PersonMutation) SetArtist(i int) {
	m.artist = &i
	m.addartist = nil
}

// Artist returns the value of the "artist" field in the mutation.
func (m *PersonMutation) Artist() (r int, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtist returns the old "artist" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldArtist(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArtist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtist: %w", err)
	}
	return oldValue.Artist, nil
}

// AddArtist adds i to the "artist" field.
func (m *PersonMutation) AddArtist(i int) {
	if m.addartist != nil {
		*m.addartist += i
	} else {
		m.addartist = &i
	}
}

// AddedArtist returns the value that was added to the "artist" field in this mutation.
func (m *PersonMutation) AddedArtist() (r int, exists bool) {
	v := m.addartist
	if v == nil {
		return
	}
	return *v, true
}

// ResetArtist resets all changes to the "artist" field.
func (m *PersonMutation) ResetArtist() {
	m.artist = nil
	m.addartist = nil
}

// SetSeiyu sets the "seiyu" field.
func (m *PersonMutation) SetSeiyu(i int) {
	m.seiyu = &i
	m.addseiyu = nil
}

// Seiyu returns the value of the "seiyu" field in the mutation.
func (m *PersonMutation) Seiyu() (r int, exists bool) {
	v := m.seiyu
	if v == nil {
		return
	}
	return *v, true
}

// OldSeiyu returns the old "seiyu" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldSeiyu(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeiyu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeiyu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeiyu: %w", err)
	}
	return oldValue.Seiyu, nil
}

// AddSeiyu adds i to the "seiyu" field.
func (m *PersonMutation) AddSeiyu(i int) {
	if m.addseiyu != nil {
		*m.addseiyu += i
	} else {
		m.addseiyu = &i
	}
}

// AddedSeiyu returns the value that was added to the "seiyu" field in this mutation.
func (m *PersonMutation) AddedSeiyu() (r int, exists bool) {
	v := m.addseiyu
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeiyu resets all changes to the "seiyu" field.
func (m *PersonMutation) ResetSeiyu() {
	m.seiyu = nil
	m.addseiyu = nil
}

// SetWriter sets the "writer" field.
func (m *PersonMutation) SetWriter(i int) {
	m.writer = &i
	m.addwriter = nil
}

// Writer returns the value of the "writer" field in the mutation.
func (m *PersonMutation) Writer() (r int, exists bool) {
	v := m.writer
	if v == nil {
		return
	}
	return *v, true
}

// OldWriter returns the old "writer" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldWriter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWriter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWriter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWriter: %w", err)
	}
	return oldValue.Writer, nil
}

// AddWriter adds i to the "writer" field.
func (m *PersonMutation) AddWriter(i int) {
	if m.addwriter != nil {
		*m.addwriter += i
	} else {
		m.addwriter = &i
	}
}

// AddedWriter returns the value that was added to the "writer" field in this mutation.
func (m *PersonMutation) AddedWriter() (r int, exists bool) {
	v := m.addwriter
	if v == nil {
		return
	}
	return *v, true
}

// ResetWriter resets all changes to the "writer" field.
func (m *PersonMutation) ResetWriter() {
	m.writer = nil
	m.addwriter = nil
}

// SetIllustrator sets the "illustrator" field.
func (m *PersonMutation) SetIllustrator(i int) {
	m.illustrator = &i
	m.addillustrator = nil
}

// Illustrator returns the value of the "illustrator" field in the mutation.
func (m *PersonMutation) Illustrator() (r int, exists bool) {
	v := m.illustrator
	if v == nil {
		return
	}
	return *v, true
}

// OldIllustrator returns the old "illustrator" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIllustrator(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIllustrator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIllustrator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIllustrator: %w", err)
	}
	return oldValue.Illustrator, nil
}

// AddIllustrator adds i to the "illustrator" field.
func (m *PersonMutation) AddIllustrator(i int) {
	if m.addillustrator != nil {
		*m.addillustrator += i
	} else {
		m.addillustrator = &i
	}
}

// AddedIllustrator returns the value that was added to the "illustrator" field in this mutation.
func (m *PersonMutation) AddedIllustrator() (r int, exists bool) {
	v := m.addillustrator
	if v == nil {
		return
	}
	return *v, true
}

// ResetIllustrator resets all changes to the "illustrator" field.
func (m *PersonMutation) ResetIllustrator() {
	m.illustrator = nil
	m.addillustrator = nil
}

// SetActor sets the "actor" field.
func (m *PersonMutation) SetActor(i int) {
	m.actor = &i
	m.addactor = nil
}

// Actor returns the value of the "actor" field in the mutation.
func (m *PersonMutation) Actor() (r int, exists bool) {
	v := m.actor
	if v == nil {
		return
	}
	return *v, true
}

// OldActor returns the old "actor" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldActor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActor: %w", err)
	}
	return oldValue.Actor, nil
}

// AddActor adds i to the "actor" field.
func (m *PersonMutation) AddActor(i int) {
	if m.addactor != nil {
		*m.addactor += i
	} else {
		m.addactor = &i
	}
}

// AddedActor returns the value that was added to the "actor" field in this mutation.
func (m *PersonMutation) AddedActor() (r int, exists bool) {
	v := m.addactor
	if v == nil {
		return
	}
	return *v, true
}

// ResetActor resets all changes to the "actor" field.
func (m *PersonMutation) ResetActor() {
	m.actor = nil
	m.addactor = nil
}

// SetSummary sets the "summary" field.
func (m *PersonMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *PersonMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *PersonMutation) ResetSummary() {
	m.summary = nil
}

// SetImg sets the "img" field.
func (m *PersonMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *PersonMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *PersonMutation) ResetImg() {
	m.img = nil
}

// SetImgAnidb sets the "img_anidb" field.
func (m *PersonMutation) SetImgAnidb(s string) {
	m.img_anidb = &s
}

// ImgAnidb returns the value of the "img_anidb" field in the mutation.
func (m *PersonMutation) ImgAnidb() (r string, exists bool) {
	v := m.img_anidb
	if v == nil {
		return
	}
	return *v, true
}

// OldImgAnidb returns the old "img_anidb" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldImgAnidb(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImgAnidb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImgAnidb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgAnidb: %w", err)
	}
	return oldValue.ImgAnidb, nil
}

// ResetImgAnidb resets all changes to the "img_anidb" field.
func (m *PersonMutation) ResetImgAnidb() {
	m.img_anidb = nil
}

// SetComment sets the "comment" field.
func (m *PersonMutation) SetComment(i int) {
	m.comment = &i
	m.addcomment = nil
}

// Comment returns the value of the "comment" field in the mutation.
func (m *PersonMutation) Comment() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldComment(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// AddComment adds i to the "comment" field.
func (m *PersonMutation) AddComment(i int) {
	if m.addcomment != nil {
		*m.addcomment += i
	} else {
		m.addcomment = &i
	}
}

// AddedComment returns the value that was added to the "comment" field in this mutation.
func (m *PersonMutation) AddedComment() (r int, exists bool) {
	v := m.addcomment
	if v == nil {
		return
	}
	return *v, true
}

// ResetComment resets all changes to the "comment" field.
func (m *PersonMutation) ResetComment() {
	m.comment = nil
	m.addcomment = nil
}

// SetCollects sets the "collects" field.
func (m *PersonMutation) SetCollects(i int) {
	m.collects = &i
	m.addcollects = nil
}

// Collects returns the value of the "collects" field in the mutation.
func (m *PersonMutation) Collects() (r int, exists bool) {
	v := m.collects
	if v == nil {
		return
	}
	return *v, true
}

// OldCollects returns the old "collects" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCollects(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCollects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCollects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollects: %w", err)
	}
	return oldValue.Collects, nil
}

// AddCollects adds i to the "collects" field.
func (m *PersonMutation) AddCollects(i int) {
	if m.addcollects != nil {
		*m.addcollects += i
	} else {
		m.addcollects = &i
	}
}

// AddedCollects returns the value that was added to the "collects" field in this mutation.
func (m *PersonMutation) AddedCollects() (r int, exists bool) {
	v := m.addcollects
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollects resets all changes to the "collects" field.
func (m *PersonMutation) ResetCollects() {
	m.collects = nil
	m.addcollects = nil
}

// SetDateline sets the "dateline" field.
func (m *PersonMutation) SetDateline(i int) {
	m.dateline = &i
	m.adddateline = nil
}

// Dateline returns the value of the "dateline" field in the mutation.
func (m *PersonMutation) Dateline() (r int, exists bool) {
	v := m.dateline
	if v == nil {
		return
	}
	return *v, true
}

// OldDateline returns the old "dateline" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDateline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateline: %w", err)
	}
	return oldValue.Dateline, nil
}

// AddDateline adds i to the "dateline" field.
func (m *PersonMutation) AddDateline(i int) {
	if m.adddateline != nil {
		*m.adddateline += i
	} else {
		m.adddateline = &i
	}
}

// AddedDateline returns the value that was added to the "dateline" field in this mutation.
func (m *PersonMutation) AddedDateline() (r int, exists bool) {
	v := m.adddateline
	if v == nil {
		return
	}
	return *v, true
}

// ResetDateline resets all changes to the "dateline" field.
func (m *PersonMutation) ResetDateline() {
	m.dateline = nil
	m.adddateline = nil
}

// SetLastpost sets the "lastpost" field.
func (m *PersonMutation) SetLastpost(i int) {
	m.lastpost = &i
	m.addlastpost = nil
}

// Lastpost returns the value of the "lastpost" field in the mutation.
func (m *PersonMutation) Lastpost() (r int, exists bool) {
	v := m.lastpost
	if v == nil {
		return
	}
	return *v, true
}

// OldLastpost returns the old "lastpost" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLastpost(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastpost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastpost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastpost: %w", err)
	}
	return oldValue.Lastpost, nil
}

// AddLastpost adds i to the "lastpost" field.
func (m *PersonMutation) AddLastpost(i int) {
	if m.addlastpost != nil {
		*m.addlastpost += i
	} else {
		m.addlastpost = &i
	}
}

// AddedLastpost returns the value that was added to the "lastpost" field in this mutation.
func (m *PersonMutation) AddedLastpost() (r int, exists bool) {
	v := m.addlastpost
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastpost resets all changes to the "lastpost" field.
func (m *PersonMutation) ResetLastpost() {
	m.lastpost = nil
	m.addlastpost = nil
}

// SetLock sets the "lock" field.
func (m *PersonMutation) SetLock(i int) {
	m.lock = &i
	m.addlock = nil
}

// Lock returns the value of the "lock" field in the mutation.
func (m *PersonMutation) Lock() (r int, exists bool) {
	v := m.lock
	if v == nil {
		return
	}
	return *v, true
}

// OldLock returns the old "lock" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLock: %w", err)
	}
	return oldValue.Lock, nil
}

// AddLock adds i to the "lock" field.
func (m *PersonMutation) AddLock(i int) {
	if m.addlock != nil {
		*m.addlock += i
	} else {
		m.addlock = &i
	}
}

// AddedLock returns the value that was added to the "lock" field in this mutation.
func (m *PersonMutation) AddedLock() (r int, exists bool) {
	v := m.addlock
	if v == nil {
		return
	}
	return *v, true
}

// ResetLock resets all changes to the "lock" field.
func (m *PersonMutation) ResetLock() {
	m.lock = nil
	m.addlock = nil
}

// SetAnidbID sets the "anidb_id" field.
func (m *PersonMutation) SetAnidbID(s string) {
	m.anidb_id = &s
}

// AnidbID returns the value of the "anidb_id" field in the mutation.
func (m *PersonMutation) AnidbID() (r string, exists bool) {
	v := m.anidb_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAnidbID returns the old "anidb_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAnidbID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnidbID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnidbID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnidbID: %w", err)
	}
	return oldValue.AnidbID, nil
}

// ResetAnidbID resets all changes to the "anidb_id" field.
func (m *PersonMutation) ResetAnidbID() {
	m.anidb_id = nil
}

// SetBan sets the "ban" field.
func (m *PersonMutation) SetBan(i int) {
	m.ban = &i
	m.addban = nil
}

// Ban returns the value of the "ban" field in the mutation.
func (m *PersonMutation) Ban() (r int, exists bool) {
	v := m.ban
	if v == nil {
		return
	}
	return *v, true
}

// OldBan returns the old "ban" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBan(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBan: %w", err)
	}
	return oldValue.Ban, nil
}

// AddBan adds i to the "ban" field.
func (m *PersonMutation) AddBan(i int) {
	if m.addban != nil {
		*m.addban += i
	} else {
		m.addban = &i
	}
}

// AddedBan returns the value that was added to the "ban" field in this mutation.
func (m *PersonMutation) AddedBan() (r int, exists bool) {
	v := m.addban
	if v == nil {
		return
	}
	return *v, true
}

// ResetBan resets all changes to the "ban" field.
func (m *PersonMutation) ResetBan() {
	m.ban = nil
	m.addban = nil
}

// SetRedirect sets the "redirect" field.
func (m *PersonMutation) SetRedirect(i int) {
	m.redirect = &i
	m.addredirect = nil
}

// Redirect returns the value of the "redirect" field in the mutation.
func (m *PersonMutation) Redirect() (r int, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old "redirect" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldRedirect(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRedirect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// AddRedirect adds i to the "redirect" field.
func (m *PersonMutation) AddRedirect(i int) {
	if m.addredirect != nil {
		*m.addredirect += i
	} else {
		m.addredirect = &i
	}
}

// AddedRedirect returns the value that was added to the "redirect" field in this mutation.
func (m *PersonMutation) AddedRedirect() (r int, exists bool) {
	v := m.addredirect
	if v == nil {
		return
	}
	return *v, true
}

// ResetRedirect resets all changes to the "redirect" field.
func (m *PersonMutation) ResetRedirect() {
	m.redirect = nil
	m.addredirect = nil
}

// SetNsfw sets the "nsfw" field.
func (m *PersonMutation) SetNsfw(b bool) {
	m.nsfw = &b
}

// Nsfw returns the value of the "nsfw" field in the mutation.
func (m *PersonMutation) Nsfw() (r bool, exists bool) {
	v := m.nsfw
	if v == nil {
		return
	}
	return *v, true
}

// OldNsfw returns the old "nsfw" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldNsfw(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNsfw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNsfw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNsfw: %w", err)
	}
	return oldValue.Nsfw, nil
}

// ResetNsfw resets all changes to the "nsfw" field.
func (m *PersonMutation) ResetNsfw() {
	m.nsfw = nil
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m._type != nil {
		fields = append(fields, person.FieldType)
	}
	if m.infobox != nil {
		fields = append(fields, person.FieldInfobox)
	}
	if m.producer != nil {
		fields = append(fields, person.FieldProducer)
	}
	if m.mangaka != nil {
		fields = append(fields, person.FieldMangaka)
	}
	if m.artist != nil {
		fields = append(fields, person.FieldArtist)
	}
	if m.seiyu != nil {
		fields = append(fields, person.FieldSeiyu)
	}
	if m.writer != nil {
		fields = append(fields, person.FieldWriter)
	}
	if m.illustrator != nil {
		fields = append(fields, person.FieldIllustrator)
	}
	if m.actor != nil {
		fields = append(fields, person.FieldActor)
	}
	if m.summary != nil {
		fields = append(fields, person.FieldSummary)
	}
	if m.img != nil {
		fields = append(fields, person.FieldImg)
	}
	if m.img_anidb != nil {
		fields = append(fields, person.FieldImgAnidb)
	}
	if m.comment != nil {
		fields = append(fields, person.FieldComment)
	}
	if m.collects != nil {
		fields = append(fields, person.FieldCollects)
	}
	if m.dateline != nil {
		fields = append(fields, person.FieldDateline)
	}
	if m.lastpost != nil {
		fields = append(fields, person.FieldLastpost)
	}
	if m.lock != nil {
		fields = append(fields, person.FieldLock)
	}
	if m.anidb_id != nil {
		fields = append(fields, person.FieldAnidbID)
	}
	if m.ban != nil {
		fields = append(fields, person.FieldBan)
	}
	if m.redirect != nil {
		fields = append(fields, person.FieldRedirect)
	}
	if m.nsfw != nil {
		fields = append(fields, person.FieldNsfw)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldName:
		return m.Name()
	case person.FieldType:
		return m.GetType()
	case person.FieldInfobox:
		return m.Infobox()
	case person.FieldProducer:
		return m.Producer()
	case person.FieldMangaka:
		return m.Mangaka()
	case person.FieldArtist:
		return m.Artist()
	case person.FieldSeiyu:
		return m.Seiyu()
	case person.FieldWriter:
		return m.Writer()
	case person.FieldIllustrator:
		return m.Illustrator()
	case person.FieldActor:
		return m.Actor()
	case person.FieldSummary:
		return m.Summary()
	case person.FieldImg:
		return m.Img()
	case person.FieldImgAnidb:
		return m.ImgAnidb()
	case person.FieldComment:
		return m.Comment()
	case person.FieldCollects:
		return m.Collects()
	case person.FieldDateline:
		return m.Dateline()
	case person.FieldLastpost:
		return m.Lastpost()
	case person.FieldLock:
		return m.Lock()
	case person.FieldAnidbID:
		return m.AnidbID()
	case person.FieldBan:
		return m.Ban()
	case person.FieldRedirect:
		return m.Redirect()
	case person.FieldNsfw:
		return m.Nsfw()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldName:
		return m.OldName(ctx)
	case person.FieldType:
		return m.OldType(ctx)
	case person.FieldInfobox:
		return m.OldInfobox(ctx)
	case person.FieldProducer:
		return m.OldProducer(ctx)
	case person.FieldMangaka:
		return m.OldMangaka(ctx)
	case person.FieldArtist:
		return m.OldArtist(ctx)
	case person.FieldSeiyu:
		return m.OldSeiyu(ctx)
	case person.FieldWriter:
		return m.OldWriter(ctx)
	case person.FieldIllustrator:
		return m.OldIllustrator(ctx)
	case person.FieldActor:
		return m.OldActor(ctx)
	case person.FieldSummary:
		return m.OldSummary(ctx)
	case person.FieldImg:
		return m.OldImg(ctx)
	case person.FieldImgAnidb:
		return m.OldImgAnidb(ctx)
	case person.FieldComment:
		return m.OldComment(ctx)
	case person.FieldCollects:
		return m.OldCollects(ctx)
	case person.FieldDateline:
		return m.OldDateline(ctx)
	case person.FieldLastpost:
		return m.OldLastpost(ctx)
	case person.FieldLock:
		return m.OldLock(ctx)
	case person.FieldAnidbID:
		return m.OldAnidbID(ctx)
	case person.FieldBan:
		return m.OldBan(ctx)
	case person.FieldRedirect:
		return m.OldRedirect(ctx)
	case person.FieldNsfw:
		return m.OldNsfw(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case person.FieldInfobox:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfobox(v)
		return nil
	case person.FieldProducer:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProducer(v)
		return nil
	case person.FieldMangaka:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMangaka(v)
		return nil
	case person.FieldArtist:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtist(v)
		return nil
	case person.FieldSeiyu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeiyu(v)
		return nil
	case person.FieldWriter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWriter(v)
		return nil
	case person.FieldIllustrator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIllustrator(v)
		return nil
	case person.FieldActor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActor(v)
		return nil
	case person.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case person.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case person.FieldImgAnidb:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgAnidb(v)
		return nil
	case person.FieldComment:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case person.FieldCollects:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollects(v)
		return nil
	case person.FieldDateline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateline(v)
		return nil
	case person.FieldLastpost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastpost(v)
		return nil
	case person.FieldLock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLock(v)
		return nil
	case person.FieldAnidbID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnidbID(v)
		return nil
	case person.FieldBan:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBan(v)
		return nil
	case person.FieldRedirect:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case person.FieldNsfw:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNsfw(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	var fields []string
	if m.addproducer != nil {
		fields = append(fields, person.FieldProducer)
	}
	if m.addmangaka != nil {
		fields = append(fields, person.FieldMangaka)
	}
	if m.addartist != nil {
		fields = append(fields, person.FieldArtist)
	}
	if m.addseiyu != nil {
		fields = append(fields, person.FieldSeiyu)
	}
	if m.addwriter != nil {
		fields = append(fields, person.FieldWriter)
	}
	if m.addillustrator != nil {
		fields = append(fields, person.FieldIllustrator)
	}
	if m.addactor != nil {
		fields = append(fields, person.FieldActor)
	}
	if m.addcomment != nil {
		fields = append(fields, person.FieldComment)
	}
	if m.addcollects != nil {
		fields = append(fields, person.FieldCollects)
	}
	if m.adddateline != nil {
		fields = append(fields, person.FieldDateline)
	}
	if m.addlastpost != nil {
		fields = append(fields, person.FieldLastpost)
	}
	if m.addlock != nil {
		fields = append(fields, person.FieldLock)
	}
	if m.addban != nil {
		fields = append(fields, person.FieldBan)
	}
	if m.addredirect != nil {
		fields = append(fields, person.FieldRedirect)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case person.FieldProducer:
		return m.AddedProducer()
	case person.FieldMangaka:
		return m.AddedMangaka()
	case person.FieldArtist:
		return m.AddedArtist()
	case person.FieldSeiyu:
		return m.AddedSeiyu()
	case person.FieldWriter:
		return m.AddedWriter()
	case person.FieldIllustrator:
		return m.AddedIllustrator()
	case person.FieldActor:
		return m.AddedActor()
	case person.FieldComment:
		return m.AddedComment()
	case person.FieldCollects:
		return m.AddedCollects()
	case person.FieldDateline:
		return m.AddedDateline()
	case person.FieldLastpost:
		return m.AddedLastpost()
	case person.FieldLock:
		return m.AddedLock()
	case person.FieldBan:
		return m.AddedBan()
	case person.FieldRedirect:
		return m.AddedRedirect()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case person.FieldProducer:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProducer(v)
		return nil
	case person.FieldMangaka:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMangaka(v)
		return nil
	case person.FieldArtist:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArtist(v)
		return nil
	case person.FieldSeiyu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeiyu(v)
		return nil
	case person.FieldWriter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWriter(v)
		return nil
	case person.FieldIllustrator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIllustrator(v)
		return nil
	case person.FieldActor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActor(v)
		return nil
	case person.FieldComment:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddComment(v)
		return nil
	case person.FieldCollects:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollects(v)
		return nil
	case person.FieldDateline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDateline(v)
		return nil
	case person.FieldLastpost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastpost(v)
		return nil
	case person.FieldLock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLock(v)
		return nil
	case person.FieldBan:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBan(v)
		return nil
	case person.FieldRedirect:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRedirect(v)
		return nil
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldType:
		m.ResetType()
		return nil
	case person.FieldInfobox:
		m.ResetInfobox()
		return nil
	case person.FieldProducer:
		m.ResetProducer()
		return nil
	case person.FieldMangaka:
		m.ResetMangaka()
		return nil
	case person.FieldArtist:
		m.ResetArtist()
		return nil
	case person.FieldSeiyu:
		m.ResetSeiyu()
		return nil
	case person.FieldWriter:
		m.ResetWriter()
		return nil
	case person.FieldIllustrator:
		m.ResetIllustrator()
		return nil
	case person.FieldActor:
		m.ResetActor()
		return nil
	case person.FieldSummary:
		m.ResetSummary()
		return nil
	case person.FieldImg:
		m.ResetImg()
		return nil
	case person.FieldImgAnidb:
		m.ResetImgAnidb()
		return nil
	case person.FieldComment:
		m.ResetComment()
		return nil
	case person.FieldCollects:
		m.ResetCollects()
		return nil
	case person.FieldDateline:
		m.ResetDateline()
		return nil
	case person.FieldLastpost:
		m.ResetLastpost()
		return nil
	case person.FieldLock:
		m.ResetLock()
		return nil
	case person.FieldAnidbID:
		m.ResetAnidbID()
		return nil
	case person.FieldBan:
		m.ResetBan()
		return nil
	case person.FieldRedirect:
		m.ResetRedirect()
		return nil
	case person.FieldNsfw:
		m.ResetNsfw()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Person edge %s", name)
}

// PersonCsIndexMutation represents an operation that mutates the PersonCsIndex nodes in the graph.
type PersonCsIndexMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint8
	prsn_type          *personcsindex.PrsnType
	prsn_position      *int
	addprsn_position   *int
	subject_id         *int
	addsubject_id      *int
	subject_type_id    *int
	addsubject_type_id *int
	summary            *string
	appear_eps         *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*PersonCsIndex, error)
	predicates         []predicate.PersonCsIndex
}

var _ ent.Mutation = (*PersonCsIndexMutation)(nil)

// personcsindexOption allows management of the mutation configuration using functional options.
type personcsindexOption func(*PersonCsIndexMutation)

// newPersonCsIndexMutation creates new mutation for the PersonCsIndex entity.
func newPersonCsIndexMutation(c config, op Op, opts ...personcsindexOption) *PersonCsIndexMutation {
	m := &PersonCsIndexMutation{
		config:        c,
		op:            op,
		typ:           TypePersonCsIndex,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonCsIndexID sets the ID field of the mutation.
func withPersonCsIndexID(id uint8) personcsindexOption {
	return func(m *PersonCsIndexMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonCsIndex
		)
		m.oldValue = func(ctx context.Context) (*PersonCsIndex, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonCsIndex.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonCsIndex sets the old PersonCsIndex of the mutation.
func withPersonCsIndex(node *PersonCsIndex) personcsindexOption {
	return func(m *PersonCsIndexMutation) {
		m.oldValue = func(context.Context) (*PersonCsIndex, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonCsIndexMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonCsIndexMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PersonCsIndex entities.
func (m *PersonCsIndexMutation) SetID(id uint8) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonCsIndexMutation) ID() (id uint8, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrsnType sets the "prsn_type" field.
func (m *PersonCsIndexMutation) SetPrsnType(pt personcsindex.PrsnType) {
	m.prsn_type = &pt
}

// PrsnType returns the value of the "prsn_type" field in the mutation.
func (m *PersonCsIndexMutation) PrsnType() (r personcsindex.PrsnType, exists bool) {
	v := m.prsn_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPrsnType returns the old "prsn_type" field's value of the PersonCsIndex entity.
// If the PersonCsIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonCsIndexMutation) OldPrsnType(ctx context.Context) (v personcsindex.PrsnType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrsnType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrsnType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrsnType: %w", err)
	}
	return oldValue.PrsnType, nil
}

// ResetPrsnType resets all changes to the "prsn_type" field.
func (m *PersonCsIndexMutation) ResetPrsnType() {
	m.prsn_type = nil
}

// SetPrsnPosition sets the "prsn_position" field.
func (m *PersonCsIndexMutation) SetPrsnPosition(i int) {
	m.prsn_position = &i
	m.addprsn_position = nil
}

// PrsnPosition returns the value of the "prsn_position" field in the mutation.
func (m *PersonCsIndexMutation) PrsnPosition() (r int, exists bool) {
	v := m.prsn_position
	if v == nil {
		return
	}
	return *v, true
}

// OldPrsnPosition returns the old "prsn_position" field's value of the PersonCsIndex entity.
// If the PersonCsIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonCsIndexMutation) OldPrsnPosition(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrsnPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrsnPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrsnPosition: %w", err)
	}
	return oldValue.PrsnPosition, nil
}

// AddPrsnPosition adds i to the "prsn_position" field.
func (m *PersonCsIndexMutation) AddPrsnPosition(i int) {
	if m.addprsn_position != nil {
		*m.addprsn_position += i
	} else {
		m.addprsn_position = &i
	}
}

// AddedPrsnPosition returns the value that was added to the "prsn_position" field in this mutation.
func (m *PersonCsIndexMutation) AddedPrsnPosition() (r int, exists bool) {
	v := m.addprsn_position
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrsnPosition resets all changes to the "prsn_position" field.
func (m *PersonCsIndexMutation) ResetPrsnPosition() {
	m.prsn_position = nil
	m.addprsn_position = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *PersonCsIndexMutation) SetSubjectID(i int) {
	m.subject_id = &i
	m.addsubject_id = nil
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *PersonCsIndexMutation) SubjectID() (r int, exists bool) {
	v := m.subject_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the PersonCsIndex entity.
// If the PersonCsIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonCsIndexMutation) OldSubjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// AddSubjectID adds i to the "subject_id" field.
func (m *PersonCsIndexMutation) AddSubjectID(i int) {
	if m.addsubject_id != nil {
		*m.addsubject_id += i
	} else {
		m.addsubject_id = &i
	}
}

// AddedSubjectID returns the value that was added to the "subject_id" field in this mutation.
func (m *PersonCsIndexMutation) AddedSubjectID() (r int, exists bool) {
	v := m.addsubject_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *PersonCsIndexMutation) ResetSubjectID() {
	m.subject_id = nil
	m.addsubject_id = nil
}

// SetSubjectTypeID sets the "subject_type_id" field.
func (m *PersonCsIndexMutation) SetSubjectTypeID(i int) {
	m.subject_type_id = &i
	m.addsubject_type_id = nil
}

// SubjectTypeID returns the value of the "subject_type_id" field in the mutation.
func (m *PersonCsIndexMutation) SubjectTypeID() (r int, exists bool) {
	v := m.subject_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectTypeID returns the old "subject_type_id" field's value of the PersonCsIndex entity.
// If the PersonCsIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonCsIndexMutation) OldSubjectTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjectTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjectTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectTypeID: %w", err)
	}
	return oldValue.SubjectTypeID, nil
}

// AddSubjectTypeID adds i to the "subject_type_id" field.
func (m *PersonCsIndexMutation) AddSubjectTypeID(i int) {
	if m.addsubject_type_id != nil {
		*m.addsubject_type_id += i
	} else {
		m.addsubject_type_id = &i
	}
}

// AddedSubjectTypeID returns the value that was added to the "subject_type_id" field in this mutation.
func (m *PersonCsIndexMutation) AddedSubjectTypeID() (r int, exists bool) {
	v := m.addsubject_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubjectTypeID resets all changes to the "subject_type_id" field.
func (m *PersonCsIndexMutation) ResetSubjectTypeID() {
	m.subject_type_id = nil
	m.addsubject_type_id = nil
}

// SetSummary sets the "summary" field.
func (m *PersonCsIndexMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *PersonCsIndexMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the PersonCsIndex entity.
// If the PersonCsIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonCsIndexMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *PersonCsIndexMutation) ResetSummary() {
	m.summary = nil
}

// SetAppearEps sets the "appear_eps" field.
func (m *PersonCsIndexMutation) SetAppearEps(s string) {
	m.appear_eps = &s
}

// AppearEps returns the value of the "appear_eps" field in the mutation.
func (m *PersonCsIndexMutation) AppearEps() (r string, exists bool) {
	v := m.appear_eps
	if v == nil {
		return
	}
	return *v, true
}

// OldAppearEps returns the old "appear_eps" field's value of the PersonCsIndex entity.
// If the PersonCsIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonCsIndexMutation) OldAppearEps(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppearEps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppearEps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppearEps: %w", err)
	}
	return oldValue.AppearEps, nil
}

// ResetAppearEps resets all changes to the "appear_eps" field.
func (m *PersonCsIndexMutation) ResetAppearEps() {
	m.appear_eps = nil
}

// Where appends a list predicates to the PersonCsIndexMutation builder.
func (m *PersonCsIndexMutation) Where(ps ...predicate.PersonCsIndex) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PersonCsIndexMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PersonCsIndex).
func (m *PersonCsIndexMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonCsIndexMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.prsn_type != nil {
		fields = append(fields, personcsindex.FieldPrsnType)
	}
	if m.prsn_position != nil {
		fields = append(fields, personcsindex.FieldPrsnPosition)
	}
	if m.subject_id != nil {
		fields = append(fields, personcsindex.FieldSubjectID)
	}
	if m.subject_type_id != nil {
		fields = append(fields, personcsindex.FieldSubjectTypeID)
	}
	if m.summary != nil {
		fields = append(fields, personcsindex.FieldSummary)
	}
	if m.appear_eps != nil {
		fields = append(fields, personcsindex.FieldAppearEps)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonCsIndexMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personcsindex.FieldPrsnType:
		return m.PrsnType()
	case personcsindex.FieldPrsnPosition:
		return m.PrsnPosition()
	case personcsindex.FieldSubjectID:
		return m.SubjectID()
	case personcsindex.FieldSubjectTypeID:
		return m.SubjectTypeID()
	case personcsindex.FieldSummary:
		return m.Summary()
	case personcsindex.FieldAppearEps:
		return m.AppearEps()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonCsIndexMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personcsindex.FieldPrsnType:
		return m.OldPrsnType(ctx)
	case personcsindex.FieldPrsnPosition:
		return m.OldPrsnPosition(ctx)
	case personcsindex.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case personcsindex.FieldSubjectTypeID:
		return m.OldSubjectTypeID(ctx)
	case personcsindex.FieldSummary:
		return m.OldSummary(ctx)
	case personcsindex.FieldAppearEps:
		return m.OldAppearEps(ctx)
	}
	return nil, fmt.Errorf("unknown PersonCsIndex field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonCsIndexMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personcsindex.FieldPrsnType:
		v, ok := value.(personcsindex.PrsnType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrsnType(v)
		return nil
	case personcsindex.FieldPrsnPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrsnPosition(v)
		return nil
	case personcsindex.FieldSubjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case personcsindex.FieldSubjectTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectTypeID(v)
		return nil
	case personcsindex.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case personcsindex.FieldAppearEps:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppearEps(v)
		return nil
	}
	return fmt.Errorf("unknown PersonCsIndex field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonCsIndexMutation) AddedFields() []string {
	var fields []string
	if m.addprsn_position != nil {
		fields = append(fields, personcsindex.FieldPrsnPosition)
	}
	if m.addsubject_id != nil {
		fields = append(fields, personcsindex.FieldSubjectID)
	}
	if m.addsubject_type_id != nil {
		fields = append(fields, personcsindex.FieldSubjectTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonCsIndexMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case personcsindex.FieldPrsnPosition:
		return m.AddedPrsnPosition()
	case personcsindex.FieldSubjectID:
		return m.AddedSubjectID()
	case personcsindex.FieldSubjectTypeID:
		return m.AddedSubjectTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonCsIndexMutation) AddField(name string, value ent.Value) error {
	switch name {
	case personcsindex.FieldPrsnPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrsnPosition(v)
		return nil
	case personcsindex.FieldSubjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubjectID(v)
		return nil
	case personcsindex.FieldSubjectTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubjectTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown PersonCsIndex numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonCsIndexMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonCsIndexMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonCsIndexMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PersonCsIndex nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonCsIndexMutation) ResetField(name string) error {
	switch name {
	case personcsindex.FieldPrsnType:
		m.ResetPrsnType()
		return nil
	case personcsindex.FieldPrsnPosition:
		m.ResetPrsnPosition()
		return nil
	case personcsindex.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case personcsindex.FieldSubjectTypeID:
		m.ResetSubjectTypeID()
		return nil
	case personcsindex.FieldSummary:
		m.ResetSummary()
		return nil
	case personcsindex.FieldAppearEps:
		m.ResetAppearEps()
		return nil
	}
	return fmt.Errorf("unknown PersonCsIndex field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonCsIndexMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonCsIndexMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonCsIndexMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonCsIndexMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonCsIndexMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonCsIndexMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonCsIndexMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PersonCsIndex unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonCsIndexMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PersonCsIndex edge %s", name)
}

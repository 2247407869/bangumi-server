// Code generated by entc, DO NOT EDIT.

package person

import (
	"app/ent/predicate"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// Type applies equality check predicate on the "type" field. It's identical to TypeEQ.
func Type(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType), v))
	})
}

// Infobox applies equality check predicate on the "infobox" field. It's identical to InfoboxEQ.
func Infobox(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldInfobox), v))
	})
}

// Producer applies equality check predicate on the "producer" field. It's identical to ProducerEQ.
func Producer(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldProducer), v))
	})
}

// Mangaka applies equality check predicate on the "mangaka" field. It's identical to MangakaEQ.
func Mangaka(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMangaka), v))
	})
}

// Artist applies equality check predicate on the "artist" field. It's identical to ArtistEQ.
func Artist(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldArtist), v))
	})
}

// Seiyu applies equality check predicate on the "seiyu" field. It's identical to SeiyuEQ.
func Seiyu(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSeiyu), v))
	})
}

// Writer applies equality check predicate on the "writer" field. It's identical to WriterEQ.
func Writer(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWriter), v))
	})
}

// Illustrator applies equality check predicate on the "illustrator" field. It's identical to IllustratorEQ.
func Illustrator(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIllustrator), v))
	})
}

// Actor applies equality check predicate on the "actor" field. It's identical to ActorEQ.
func Actor(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldActor), v))
	})
}

// Summary applies equality check predicate on the "summary" field. It's identical to SummaryEQ.
func Summary(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSummary), v))
	})
}

// Img applies equality check predicate on the "img" field. It's identical to ImgEQ.
func Img(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldImg), v))
	})
}

// ImgAnidb applies equality check predicate on the "img_anidb" field. It's identical to ImgAnidbEQ.
func ImgAnidb(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldImgAnidb), v))
	})
}

// Comment applies equality check predicate on the "comment" field. It's identical to CommentEQ.
func Comment(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldComment), v))
	})
}

// Collects applies equality check predicate on the "collects" field. It's identical to CollectsEQ.
func Collects(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCollects), v))
	})
}

// Dateline applies equality check predicate on the "dateline" field. It's identical to DatelineEQ.
func Dateline(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateline), v))
	})
}

// Lastpost applies equality check predicate on the "lastpost" field. It's identical to LastpostEQ.
func Lastpost(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastpost), v))
	})
}

// Lock applies equality check predicate on the "lock" field. It's identical to LockEQ.
func Lock(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLock), v))
	})
}

// AnidbID applies equality check predicate on the "anidb_id" field. It's identical to AnidbIDEQ.
func AnidbID(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAnidbID), v))
	})
}

// Ban applies equality check predicate on the "ban" field. It's identical to BanEQ.
func Ban(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBan), v))
	})
}

// Redirect applies equality check predicate on the "redirect" field. It's identical to RedirectEQ.
func Redirect(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRedirect), v))
	})
}

// Nsfw applies equality check predicate on the "nsfw" field. It's identical to NsfwEQ.
func Nsfw(v bool) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNsfw), v))
	})
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldName), v))
	})
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldName), v...))
	})
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldName), v...))
	})
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldName), v))
	})
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldName), v))
	})
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldName), v))
	})
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldName), v))
	})
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldName), v))
	})
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldName), v))
	})
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldName), v))
	})
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldName), v))
	})
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldName), v))
	})
}

// TypeEQ applies the EQ predicate on the "type" field.
func TypeEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType), v))
	})
}

// TypeNEQ applies the NEQ predicate on the "type" field.
func TypeNEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldType), v))
	})
}

// TypeIn applies the In predicate on the "type" field.
func TypeIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldType), v...))
	})
}

// TypeNotIn applies the NotIn predicate on the "type" field.
func TypeNotIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldType), v...))
	})
}

// TypeGT applies the GT predicate on the "type" field.
func TypeGT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldType), v))
	})
}

// TypeGTE applies the GTE predicate on the "type" field.
func TypeGTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldType), v))
	})
}

// TypeLT applies the LT predicate on the "type" field.
func TypeLT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldType), v))
	})
}

// TypeLTE applies the LTE predicate on the "type" field.
func TypeLTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldType), v))
	})
}

// TypeContains applies the Contains predicate on the "type" field.
func TypeContains(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldType), v))
	})
}

// TypeHasPrefix applies the HasPrefix predicate on the "type" field.
func TypeHasPrefix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldType), v))
	})
}

// TypeHasSuffix applies the HasSuffix predicate on the "type" field.
func TypeHasSuffix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldType), v))
	})
}

// TypeEqualFold applies the EqualFold predicate on the "type" field.
func TypeEqualFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldType), v))
	})
}

// TypeContainsFold applies the ContainsFold predicate on the "type" field.
func TypeContainsFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldType), v))
	})
}

// InfoboxEQ applies the EQ predicate on the "infobox" field.
func InfoboxEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldInfobox), v))
	})
}

// InfoboxNEQ applies the NEQ predicate on the "infobox" field.
func InfoboxNEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldInfobox), v))
	})
}

// InfoboxIn applies the In predicate on the "infobox" field.
func InfoboxIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldInfobox), v...))
	})
}

// InfoboxNotIn applies the NotIn predicate on the "infobox" field.
func InfoboxNotIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldInfobox), v...))
	})
}

// InfoboxGT applies the GT predicate on the "infobox" field.
func InfoboxGT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldInfobox), v))
	})
}

// InfoboxGTE applies the GTE predicate on the "infobox" field.
func InfoboxGTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldInfobox), v))
	})
}

// InfoboxLT applies the LT predicate on the "infobox" field.
func InfoboxLT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldInfobox), v))
	})
}

// InfoboxLTE applies the LTE predicate on the "infobox" field.
func InfoboxLTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldInfobox), v))
	})
}

// InfoboxContains applies the Contains predicate on the "infobox" field.
func InfoboxContains(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldInfobox), v))
	})
}

// InfoboxHasPrefix applies the HasPrefix predicate on the "infobox" field.
func InfoboxHasPrefix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldInfobox), v))
	})
}

// InfoboxHasSuffix applies the HasSuffix predicate on the "infobox" field.
func InfoboxHasSuffix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldInfobox), v))
	})
}

// InfoboxEqualFold applies the EqualFold predicate on the "infobox" field.
func InfoboxEqualFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldInfobox), v))
	})
}

// InfoboxContainsFold applies the ContainsFold predicate on the "infobox" field.
func InfoboxContainsFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldInfobox), v))
	})
}

// ProducerEQ applies the EQ predicate on the "producer" field.
func ProducerEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldProducer), v))
	})
}

// ProducerNEQ applies the NEQ predicate on the "producer" field.
func ProducerNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldProducer), v))
	})
}

// ProducerIn applies the In predicate on the "producer" field.
func ProducerIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldProducer), v...))
	})
}

// ProducerNotIn applies the NotIn predicate on the "producer" field.
func ProducerNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldProducer), v...))
	})
}

// ProducerGT applies the GT predicate on the "producer" field.
func ProducerGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldProducer), v))
	})
}

// ProducerGTE applies the GTE predicate on the "producer" field.
func ProducerGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldProducer), v))
	})
}

// ProducerLT applies the LT predicate on the "producer" field.
func ProducerLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldProducer), v))
	})
}

// ProducerLTE applies the LTE predicate on the "producer" field.
func ProducerLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldProducer), v))
	})
}

// MangakaEQ applies the EQ predicate on the "mangaka" field.
func MangakaEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMangaka), v))
	})
}

// MangakaNEQ applies the NEQ predicate on the "mangaka" field.
func MangakaNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMangaka), v))
	})
}

// MangakaIn applies the In predicate on the "mangaka" field.
func MangakaIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMangaka), v...))
	})
}

// MangakaNotIn applies the NotIn predicate on the "mangaka" field.
func MangakaNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMangaka), v...))
	})
}

// MangakaGT applies the GT predicate on the "mangaka" field.
func MangakaGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMangaka), v))
	})
}

// MangakaGTE applies the GTE predicate on the "mangaka" field.
func MangakaGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMangaka), v))
	})
}

// MangakaLT applies the LT predicate on the "mangaka" field.
func MangakaLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMangaka), v))
	})
}

// MangakaLTE applies the LTE predicate on the "mangaka" field.
func MangakaLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMangaka), v))
	})
}

// ArtistEQ applies the EQ predicate on the "artist" field.
func ArtistEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldArtist), v))
	})
}

// ArtistNEQ applies the NEQ predicate on the "artist" field.
func ArtistNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldArtist), v))
	})
}

// ArtistIn applies the In predicate on the "artist" field.
func ArtistIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldArtist), v...))
	})
}

// ArtistNotIn applies the NotIn predicate on the "artist" field.
func ArtistNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldArtist), v...))
	})
}

// ArtistGT applies the GT predicate on the "artist" field.
func ArtistGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldArtist), v))
	})
}

// ArtistGTE applies the GTE predicate on the "artist" field.
func ArtistGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldArtist), v))
	})
}

// ArtistLT applies the LT predicate on the "artist" field.
func ArtistLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldArtist), v))
	})
}

// ArtistLTE applies the LTE predicate on the "artist" field.
func ArtistLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldArtist), v))
	})
}

// SeiyuEQ applies the EQ predicate on the "seiyu" field.
func SeiyuEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSeiyu), v))
	})
}

// SeiyuNEQ applies the NEQ predicate on the "seiyu" field.
func SeiyuNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSeiyu), v))
	})
}

// SeiyuIn applies the In predicate on the "seiyu" field.
func SeiyuIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSeiyu), v...))
	})
}

// SeiyuNotIn applies the NotIn predicate on the "seiyu" field.
func SeiyuNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSeiyu), v...))
	})
}

// SeiyuGT applies the GT predicate on the "seiyu" field.
func SeiyuGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSeiyu), v))
	})
}

// SeiyuGTE applies the GTE predicate on the "seiyu" field.
func SeiyuGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSeiyu), v))
	})
}

// SeiyuLT applies the LT predicate on the "seiyu" field.
func SeiyuLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSeiyu), v))
	})
}

// SeiyuLTE applies the LTE predicate on the "seiyu" field.
func SeiyuLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSeiyu), v))
	})
}

// WriterEQ applies the EQ predicate on the "writer" field.
func WriterEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWriter), v))
	})
}

// WriterNEQ applies the NEQ predicate on the "writer" field.
func WriterNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWriter), v))
	})
}

// WriterIn applies the In predicate on the "writer" field.
func WriterIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWriter), v...))
	})
}

// WriterNotIn applies the NotIn predicate on the "writer" field.
func WriterNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWriter), v...))
	})
}

// WriterGT applies the GT predicate on the "writer" field.
func WriterGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWriter), v))
	})
}

// WriterGTE applies the GTE predicate on the "writer" field.
func WriterGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWriter), v))
	})
}

// WriterLT applies the LT predicate on the "writer" field.
func WriterLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWriter), v))
	})
}

// WriterLTE applies the LTE predicate on the "writer" field.
func WriterLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWriter), v))
	})
}

// IllustratorEQ applies the EQ predicate on the "illustrator" field.
func IllustratorEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIllustrator), v))
	})
}

// IllustratorNEQ applies the NEQ predicate on the "illustrator" field.
func IllustratorNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIllustrator), v))
	})
}

// IllustratorIn applies the In predicate on the "illustrator" field.
func IllustratorIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIllustrator), v...))
	})
}

// IllustratorNotIn applies the NotIn predicate on the "illustrator" field.
func IllustratorNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIllustrator), v...))
	})
}

// IllustratorGT applies the GT predicate on the "illustrator" field.
func IllustratorGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldIllustrator), v))
	})
}

// IllustratorGTE applies the GTE predicate on the "illustrator" field.
func IllustratorGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldIllustrator), v))
	})
}

// IllustratorLT applies the LT predicate on the "illustrator" field.
func IllustratorLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldIllustrator), v))
	})
}

// IllustratorLTE applies the LTE predicate on the "illustrator" field.
func IllustratorLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldIllustrator), v))
	})
}

// ActorEQ applies the EQ predicate on the "actor" field.
func ActorEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldActor), v))
	})
}

// ActorNEQ applies the NEQ predicate on the "actor" field.
func ActorNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldActor), v))
	})
}

// ActorIn applies the In predicate on the "actor" field.
func ActorIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldActor), v...))
	})
}

// ActorNotIn applies the NotIn predicate on the "actor" field.
func ActorNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldActor), v...))
	})
}

// ActorGT applies the GT predicate on the "actor" field.
func ActorGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldActor), v))
	})
}

// ActorGTE applies the GTE predicate on the "actor" field.
func ActorGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldActor), v))
	})
}

// ActorLT applies the LT predicate on the "actor" field.
func ActorLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldActor), v))
	})
}

// ActorLTE applies the LTE predicate on the "actor" field.
func ActorLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldActor), v))
	})
}

// SummaryEQ applies the EQ predicate on the "summary" field.
func SummaryEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSummary), v))
	})
}

// SummaryNEQ applies the NEQ predicate on the "summary" field.
func SummaryNEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSummary), v))
	})
}

// SummaryIn applies the In predicate on the "summary" field.
func SummaryIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSummary), v...))
	})
}

// SummaryNotIn applies the NotIn predicate on the "summary" field.
func SummaryNotIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSummary), v...))
	})
}

// SummaryGT applies the GT predicate on the "summary" field.
func SummaryGT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSummary), v))
	})
}

// SummaryGTE applies the GTE predicate on the "summary" field.
func SummaryGTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSummary), v))
	})
}

// SummaryLT applies the LT predicate on the "summary" field.
func SummaryLT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSummary), v))
	})
}

// SummaryLTE applies the LTE predicate on the "summary" field.
func SummaryLTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSummary), v))
	})
}

// SummaryContains applies the Contains predicate on the "summary" field.
func SummaryContains(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSummary), v))
	})
}

// SummaryHasPrefix applies the HasPrefix predicate on the "summary" field.
func SummaryHasPrefix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSummary), v))
	})
}

// SummaryHasSuffix applies the HasSuffix predicate on the "summary" field.
func SummaryHasSuffix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSummary), v))
	})
}

// SummaryEqualFold applies the EqualFold predicate on the "summary" field.
func SummaryEqualFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSummary), v))
	})
}

// SummaryContainsFold applies the ContainsFold predicate on the "summary" field.
func SummaryContainsFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSummary), v))
	})
}

// ImgEQ applies the EQ predicate on the "img" field.
func ImgEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldImg), v))
	})
}

// ImgNEQ applies the NEQ predicate on the "img" field.
func ImgNEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldImg), v))
	})
}

// ImgIn applies the In predicate on the "img" field.
func ImgIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldImg), v...))
	})
}

// ImgNotIn applies the NotIn predicate on the "img" field.
func ImgNotIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldImg), v...))
	})
}

// ImgGT applies the GT predicate on the "img" field.
func ImgGT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldImg), v))
	})
}

// ImgGTE applies the GTE predicate on the "img" field.
func ImgGTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldImg), v))
	})
}

// ImgLT applies the LT predicate on the "img" field.
func ImgLT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldImg), v))
	})
}

// ImgLTE applies the LTE predicate on the "img" field.
func ImgLTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldImg), v))
	})
}

// ImgContains applies the Contains predicate on the "img" field.
func ImgContains(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldImg), v))
	})
}

// ImgHasPrefix applies the HasPrefix predicate on the "img" field.
func ImgHasPrefix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldImg), v))
	})
}

// ImgHasSuffix applies the HasSuffix predicate on the "img" field.
func ImgHasSuffix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldImg), v))
	})
}

// ImgEqualFold applies the EqualFold predicate on the "img" field.
func ImgEqualFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldImg), v))
	})
}

// ImgContainsFold applies the ContainsFold predicate on the "img" field.
func ImgContainsFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldImg), v))
	})
}

// ImgAnidbEQ applies the EQ predicate on the "img_anidb" field.
func ImgAnidbEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbNEQ applies the NEQ predicate on the "img_anidb" field.
func ImgAnidbNEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbIn applies the In predicate on the "img_anidb" field.
func ImgAnidbIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldImgAnidb), v...))
	})
}

// ImgAnidbNotIn applies the NotIn predicate on the "img_anidb" field.
func ImgAnidbNotIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldImgAnidb), v...))
	})
}

// ImgAnidbGT applies the GT predicate on the "img_anidb" field.
func ImgAnidbGT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbGTE applies the GTE predicate on the "img_anidb" field.
func ImgAnidbGTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbLT applies the LT predicate on the "img_anidb" field.
func ImgAnidbLT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbLTE applies the LTE predicate on the "img_anidb" field.
func ImgAnidbLTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbContains applies the Contains predicate on the "img_anidb" field.
func ImgAnidbContains(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbHasPrefix applies the HasPrefix predicate on the "img_anidb" field.
func ImgAnidbHasPrefix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbHasSuffix applies the HasSuffix predicate on the "img_anidb" field.
func ImgAnidbHasSuffix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbEqualFold applies the EqualFold predicate on the "img_anidb" field.
func ImgAnidbEqualFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldImgAnidb), v))
	})
}

// ImgAnidbContainsFold applies the ContainsFold predicate on the "img_anidb" field.
func ImgAnidbContainsFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldImgAnidb), v))
	})
}

// CommentEQ applies the EQ predicate on the "comment" field.
func CommentEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldComment), v))
	})
}

// CommentNEQ applies the NEQ predicate on the "comment" field.
func CommentNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldComment), v))
	})
}

// CommentIn applies the In predicate on the "comment" field.
func CommentIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldComment), v...))
	})
}

// CommentNotIn applies the NotIn predicate on the "comment" field.
func CommentNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldComment), v...))
	})
}

// CommentGT applies the GT predicate on the "comment" field.
func CommentGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldComment), v))
	})
}

// CommentGTE applies the GTE predicate on the "comment" field.
func CommentGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldComment), v))
	})
}

// CommentLT applies the LT predicate on the "comment" field.
func CommentLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldComment), v))
	})
}

// CommentLTE applies the LTE predicate on the "comment" field.
func CommentLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldComment), v))
	})
}

// CollectsEQ applies the EQ predicate on the "collects" field.
func CollectsEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCollects), v))
	})
}

// CollectsNEQ applies the NEQ predicate on the "collects" field.
func CollectsNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCollects), v))
	})
}

// CollectsIn applies the In predicate on the "collects" field.
func CollectsIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCollects), v...))
	})
}

// CollectsNotIn applies the NotIn predicate on the "collects" field.
func CollectsNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCollects), v...))
	})
}

// CollectsGT applies the GT predicate on the "collects" field.
func CollectsGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCollects), v))
	})
}

// CollectsGTE applies the GTE predicate on the "collects" field.
func CollectsGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCollects), v))
	})
}

// CollectsLT applies the LT predicate on the "collects" field.
func CollectsLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCollects), v))
	})
}

// CollectsLTE applies the LTE predicate on the "collects" field.
func CollectsLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCollects), v))
	})
}

// DatelineEQ applies the EQ predicate on the "dateline" field.
func DatelineEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateline), v))
	})
}

// DatelineNEQ applies the NEQ predicate on the "dateline" field.
func DatelineNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateline), v))
	})
}

// DatelineIn applies the In predicate on the "dateline" field.
func DatelineIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateline), v...))
	})
}

// DatelineNotIn applies the NotIn predicate on the "dateline" field.
func DatelineNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateline), v...))
	})
}

// DatelineGT applies the GT predicate on the "dateline" field.
func DatelineGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateline), v))
	})
}

// DatelineGTE applies the GTE predicate on the "dateline" field.
func DatelineGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateline), v))
	})
}

// DatelineLT applies the LT predicate on the "dateline" field.
func DatelineLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateline), v))
	})
}

// DatelineLTE applies the LTE predicate on the "dateline" field.
func DatelineLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateline), v))
	})
}

// LastpostEQ applies the EQ predicate on the "lastpost" field.
func LastpostEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastpost), v))
	})
}

// LastpostNEQ applies the NEQ predicate on the "lastpost" field.
func LastpostNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastpost), v))
	})
}

// LastpostIn applies the In predicate on the "lastpost" field.
func LastpostIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastpost), v...))
	})
}

// LastpostNotIn applies the NotIn predicate on the "lastpost" field.
func LastpostNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastpost), v...))
	})
}

// LastpostGT applies the GT predicate on the "lastpost" field.
func LastpostGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastpost), v))
	})
}

// LastpostGTE applies the GTE predicate on the "lastpost" field.
func LastpostGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastpost), v))
	})
}

// LastpostLT applies the LT predicate on the "lastpost" field.
func LastpostLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastpost), v))
	})
}

// LastpostLTE applies the LTE predicate on the "lastpost" field.
func LastpostLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastpost), v))
	})
}

// LockEQ applies the EQ predicate on the "lock" field.
func LockEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLock), v))
	})
}

// LockNEQ applies the NEQ predicate on the "lock" field.
func LockNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLock), v))
	})
}

// LockIn applies the In predicate on the "lock" field.
func LockIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLock), v...))
	})
}

// LockNotIn applies the NotIn predicate on the "lock" field.
func LockNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLock), v...))
	})
}

// LockGT applies the GT predicate on the "lock" field.
func LockGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLock), v))
	})
}

// LockGTE applies the GTE predicate on the "lock" field.
func LockGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLock), v))
	})
}

// LockLT applies the LT predicate on the "lock" field.
func LockLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLock), v))
	})
}

// LockLTE applies the LTE predicate on the "lock" field.
func LockLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLock), v))
	})
}

// AnidbIDEQ applies the EQ predicate on the "anidb_id" field.
func AnidbIDEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAnidbID), v))
	})
}

// AnidbIDNEQ applies the NEQ predicate on the "anidb_id" field.
func AnidbIDNEQ(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAnidbID), v))
	})
}

// AnidbIDIn applies the In predicate on the "anidb_id" field.
func AnidbIDIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAnidbID), v...))
	})
}

// AnidbIDNotIn applies the NotIn predicate on the "anidb_id" field.
func AnidbIDNotIn(vs ...string) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAnidbID), v...))
	})
}

// AnidbIDGT applies the GT predicate on the "anidb_id" field.
func AnidbIDGT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAnidbID), v))
	})
}

// AnidbIDGTE applies the GTE predicate on the "anidb_id" field.
func AnidbIDGTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAnidbID), v))
	})
}

// AnidbIDLT applies the LT predicate on the "anidb_id" field.
func AnidbIDLT(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAnidbID), v))
	})
}

// AnidbIDLTE applies the LTE predicate on the "anidb_id" field.
func AnidbIDLTE(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAnidbID), v))
	})
}

// AnidbIDContains applies the Contains predicate on the "anidb_id" field.
func AnidbIDContains(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAnidbID), v))
	})
}

// AnidbIDHasPrefix applies the HasPrefix predicate on the "anidb_id" field.
func AnidbIDHasPrefix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAnidbID), v))
	})
}

// AnidbIDHasSuffix applies the HasSuffix predicate on the "anidb_id" field.
func AnidbIDHasSuffix(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAnidbID), v))
	})
}

// AnidbIDEqualFold applies the EqualFold predicate on the "anidb_id" field.
func AnidbIDEqualFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAnidbID), v))
	})
}

// AnidbIDContainsFold applies the ContainsFold predicate on the "anidb_id" field.
func AnidbIDContainsFold(v string) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAnidbID), v))
	})
}

// BanEQ applies the EQ predicate on the "ban" field.
func BanEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBan), v))
	})
}

// BanNEQ applies the NEQ predicate on the "ban" field.
func BanNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBan), v))
	})
}

// BanIn applies the In predicate on the "ban" field.
func BanIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBan), v...))
	})
}

// BanNotIn applies the NotIn predicate on the "ban" field.
func BanNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBan), v...))
	})
}

// BanGT applies the GT predicate on the "ban" field.
func BanGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBan), v))
	})
}

// BanGTE applies the GTE predicate on the "ban" field.
func BanGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBan), v))
	})
}

// BanLT applies the LT predicate on the "ban" field.
func BanLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBan), v))
	})
}

// BanLTE applies the LTE predicate on the "ban" field.
func BanLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBan), v))
	})
}

// RedirectEQ applies the EQ predicate on the "redirect" field.
func RedirectEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRedirect), v))
	})
}

// RedirectNEQ applies the NEQ predicate on the "redirect" field.
func RedirectNEQ(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRedirect), v))
	})
}

// RedirectIn applies the In predicate on the "redirect" field.
func RedirectIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRedirect), v...))
	})
}

// RedirectNotIn applies the NotIn predicate on the "redirect" field.
func RedirectNotIn(vs ...int) predicate.Person {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Person(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRedirect), v...))
	})
}

// RedirectGT applies the GT predicate on the "redirect" field.
func RedirectGT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRedirect), v))
	})
}

// RedirectGTE applies the GTE predicate on the "redirect" field.
func RedirectGTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRedirect), v))
	})
}

// RedirectLT applies the LT predicate on the "redirect" field.
func RedirectLT(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRedirect), v))
	})
}

// RedirectLTE applies the LTE predicate on the "redirect" field.
func RedirectLTE(v int) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRedirect), v))
	})
}

// NsfwEQ applies the EQ predicate on the "nsfw" field.
func NsfwEQ(v bool) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNsfw), v))
	})
}

// NsfwNEQ applies the NEQ predicate on the "nsfw" field.
func NsfwNEQ(v bool) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNsfw), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Person) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Person) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Person) predicate.Person {
	return predicate.Person(func(s *sql.Selector) {
		p(s.Not())
	})
}

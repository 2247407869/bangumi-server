// Code generated by entc, DO NOT EDIT.

package ent

import (
	"app/ent/person"
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
)

// Person is the model entity for the Person schema.
type Person struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Type holds the value of the "type" field.
	Type string `json:"type,omitempty"`
	// Infobox holds the value of the "infobox" field.
	Infobox string `json:"infobox,omitempty"`
	// Producer holds the value of the "producer" field.
	Producer int `json:"producer,omitempty"`
	// Mangaka holds the value of the "mangaka" field.
	Mangaka int `json:"mangaka,omitempty"`
	// Artist holds the value of the "artist" field.
	Artist int `json:"artist,omitempty"`
	// Seiyu holds the value of the "seiyu" field.
	Seiyu int `json:"seiyu,omitempty"`
	// Writer holds the value of the "writer" field.
	Writer int `json:"writer,omitempty"`
	// Illustrator holds the value of the "illustrator" field.
	Illustrator int `json:"illustrator,omitempty"`
	// Actor holds the value of the "actor" field.
	Actor int `json:"actor,omitempty"`
	// Summary holds the value of the "summary" field.
	Summary string `json:"summary,omitempty"`
	// Img holds the value of the "img" field.
	Img string `json:"img,omitempty"`
	// ImgAnidb holds the value of the "img_anidb" field.
	ImgAnidb string `json:"img_anidb,omitempty"`
	// Comment holds the value of the "comment" field.
	Comment int `json:"comment,omitempty"`
	// Collects holds the value of the "collects" field.
	Collects int `json:"collects,omitempty"`
	// Dateline holds the value of the "dateline" field.
	Dateline int `json:"dateline,omitempty"`
	// Lastpost holds the value of the "lastpost" field.
	Lastpost int `json:"lastpost,omitempty"`
	// Lock holds the value of the "lock" field.
	Lock int `json:"lock,omitempty"`
	// AnidbID holds the value of the "anidb_id" field.
	AnidbID string `json:"anidb_id,omitempty"`
	// Ban holds the value of the "ban" field.
	Ban int `json:"ban,omitempty"`
	// Redirect holds the value of the "redirect" field.
	Redirect int `json:"redirect,omitempty"`
	// Nsfw holds the value of the "nsfw" field.
	Nsfw bool `json:"nsfw,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Person) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case person.FieldNsfw:
			values[i] = new(sql.NullBool)
		case person.FieldID, person.FieldProducer, person.FieldMangaka, person.FieldArtist, person.FieldSeiyu, person.FieldWriter, person.FieldIllustrator, person.FieldActor, person.FieldComment, person.FieldCollects, person.FieldDateline, person.FieldLastpost, person.FieldLock, person.FieldBan, person.FieldRedirect:
			values[i] = new(sql.NullInt64)
		case person.FieldName, person.FieldType, person.FieldInfobox, person.FieldSummary, person.FieldImg, person.FieldImgAnidb, person.FieldAnidbID:
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Person", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Person fields.
func (pe *Person) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case person.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			pe.ID = int(value.Int64)
		case person.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				pe.Name = value.String
			}
		case person.FieldType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field type", values[i])
			} else if value.Valid {
				pe.Type = value.String
			}
		case person.FieldInfobox:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field infobox", values[i])
			} else if value.Valid {
				pe.Infobox = value.String
			}
		case person.FieldProducer:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field producer", values[i])
			} else if value.Valid {
				pe.Producer = int(value.Int64)
			}
		case person.FieldMangaka:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mangaka", values[i])
			} else if value.Valid {
				pe.Mangaka = int(value.Int64)
			}
		case person.FieldArtist:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field artist", values[i])
			} else if value.Valid {
				pe.Artist = int(value.Int64)
			}
		case person.FieldSeiyu:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field seiyu", values[i])
			} else if value.Valid {
				pe.Seiyu = int(value.Int64)
			}
		case person.FieldWriter:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field writer", values[i])
			} else if value.Valid {
				pe.Writer = int(value.Int64)
			}
		case person.FieldIllustrator:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field illustrator", values[i])
			} else if value.Valid {
				pe.Illustrator = int(value.Int64)
			}
		case person.FieldActor:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field actor", values[i])
			} else if value.Valid {
				pe.Actor = int(value.Int64)
			}
		case person.FieldSummary:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field summary", values[i])
			} else if value.Valid {
				pe.Summary = value.String
			}
		case person.FieldImg:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field img", values[i])
			} else if value.Valid {
				pe.Img = value.String
			}
		case person.FieldImgAnidb:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field img_anidb", values[i])
			} else if value.Valid {
				pe.ImgAnidb = value.String
			}
		case person.FieldComment:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field comment", values[i])
			} else if value.Valid {
				pe.Comment = int(value.Int64)
			}
		case person.FieldCollects:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field collects", values[i])
			} else if value.Valid {
				pe.Collects = int(value.Int64)
			}
		case person.FieldDateline:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field dateline", values[i])
			} else if value.Valid {
				pe.Dateline = int(value.Int64)
			}
		case person.FieldLastpost:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field lastpost", values[i])
			} else if value.Valid {
				pe.Lastpost = int(value.Int64)
			}
		case person.FieldLock:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field lock", values[i])
			} else if value.Valid {
				pe.Lock = int(value.Int64)
			}
		case person.FieldAnidbID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field anidb_id", values[i])
			} else if value.Valid {
				pe.AnidbID = value.String
			}
		case person.FieldBan:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field ban", values[i])
			} else if value.Valid {
				pe.Ban = int(value.Int64)
			}
		case person.FieldRedirect:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field redirect", values[i])
			} else if value.Valid {
				pe.Redirect = int(value.Int64)
			}
		case person.FieldNsfw:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field nsfw", values[i])
			} else if value.Valid {
				pe.Nsfw = value.Bool
			}
		}
	}
	return nil
}

// Update returns a builder for updating this Person.
// Note that you need to call Person.Unwrap() before calling this method if this Person
// was returned from a transaction, and the transaction was committed or rolled back.
func (pe *Person) Update() *PersonUpdateOne {
	return (&PersonClient{config: pe.config}).UpdateOne(pe)
}

// Unwrap unwraps the Person entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pe *Person) Unwrap() *Person {
	tx, ok := pe.config.driver.(*txDriver)
	if !ok {
		panic("ent: Person is not a transactional entity")
	}
	pe.config.driver = tx.drv
	return pe
}

// String implements the fmt.Stringer.
func (pe *Person) String() string {
	var builder strings.Builder
	builder.WriteString("Person(")
	builder.WriteString(fmt.Sprintf("id=%v", pe.ID))
	builder.WriteString(", name=")
	builder.WriteString(pe.Name)
	builder.WriteString(", type=")
	builder.WriteString(pe.Type)
	builder.WriteString(", infobox=")
	builder.WriteString(pe.Infobox)
	builder.WriteString(", producer=")
	builder.WriteString(fmt.Sprintf("%v", pe.Producer))
	builder.WriteString(", mangaka=")
	builder.WriteString(fmt.Sprintf("%v", pe.Mangaka))
	builder.WriteString(", artist=")
	builder.WriteString(fmt.Sprintf("%v", pe.Artist))
	builder.WriteString(", seiyu=")
	builder.WriteString(fmt.Sprintf("%v", pe.Seiyu))
	builder.WriteString(", writer=")
	builder.WriteString(fmt.Sprintf("%v", pe.Writer))
	builder.WriteString(", illustrator=")
	builder.WriteString(fmt.Sprintf("%v", pe.Illustrator))
	builder.WriteString(", actor=")
	builder.WriteString(fmt.Sprintf("%v", pe.Actor))
	builder.WriteString(", summary=")
	builder.WriteString(pe.Summary)
	builder.WriteString(", img=")
	builder.WriteString(pe.Img)
	builder.WriteString(", img_anidb=")
	builder.WriteString(pe.ImgAnidb)
	builder.WriteString(", comment=")
	builder.WriteString(fmt.Sprintf("%v", pe.Comment))
	builder.WriteString(", collects=")
	builder.WriteString(fmt.Sprintf("%v", pe.Collects))
	builder.WriteString(", dateline=")
	builder.WriteString(fmt.Sprintf("%v", pe.Dateline))
	builder.WriteString(", lastpost=")
	builder.WriteString(fmt.Sprintf("%v", pe.Lastpost))
	builder.WriteString(", lock=")
	builder.WriteString(fmt.Sprintf("%v", pe.Lock))
	builder.WriteString(", anidb_id=")
	builder.WriteString(pe.AnidbID)
	builder.WriteString(", ban=")
	builder.WriteString(fmt.Sprintf("%v", pe.Ban))
	builder.WriteString(", redirect=")
	builder.WriteString(fmt.Sprintf("%v", pe.Redirect))
	builder.WriteString(", nsfw=")
	builder.WriteString(fmt.Sprintf("%v", pe.Nsfw))
	builder.WriteByte(')')
	return builder.String()
}

// Persons is a parsable slice of Person.
type Persons []*Person

func (pe Persons) config(cfg config) {
	for _i := range pe {
		pe[_i].config = cfg
	}
}
